#!/usr/bin/env bash
# alias_completion -- Wrap completion functions around aliases
# Requires: bash_completion *
#
# Author: Jaeho Shin <netj@sparcs.org>
# Created: 2012-09-01
# Derived-from: http://stackoverflow.com/a/1793178/390044

bash_plugin_interactive() {
    alias_completion_namespace=alias_completion::
    # alias_completion::wrap_alias takes three arguments:
    # $1: The name of the alias
    # $2: The command used in the alias
    # $3: The arguments in the alias all in one string
    # Generate a wrapper completion function (completer) for an alias
    # based on the command and the given arguments, if there is a
    # completer for the command, and set the wrapper as the completer for
    # the alias.
    function alias_completion::wrap_alias() {
        [[ $# -eq 3 ]] || return 1

        local alias_name=$1; shift
        local aliased_command=$1; shift
        local alias_definition=$1; shift

        # The completion currently being used for the aliased command.
        local completion=$(complete -p $aliased_command 2>/dev/null)
        if [[ -z $completion ]] && type _completion_loader &>/dev/null; then
            # cope with bash-completion 2 lazy loading
            _completion_loader $aliased_command
            completion=$(complete -p $aliased_command 2>/dev/null)
        fi

        # Only a completer based on a function can be wrapped so look for -F
        # in the current completion. This check will also catch commands
        # with no completer for which $completion will be empty.
        grep -q -- -F <<<"$completion" || return 0

        # Extract the name of the completion function from a string that
        # looks like: something -F function_name something
        # First strip the beginning of the string up to the function name by
        # removing "* -F " from the front.
        local completion_function=${completion##* -F }
        # Then strip " *" from the end, leaving only the function name.
        completion_function=${completion_function%% *}

        # Try to prevent an infinite loop by not wrapping a function
        # generated by this function. This can happen when the user runs
        # this twice for an alias like ls='ls --color=auto' or alias l='ls'
        # and alias ls='l foo'
        [[ "${completion_function#$alias_completion_namespace}" = $completion_function ]] ||
            return 0

        local wrapper_name="${alias_completion_namespace}${alias_name}"
        eval "
        function ${wrapper_name}() {
            local args=
            eval \"args=($alias_definition)\"
            let COMP_CWORD+=\${#args[@]}-1
            COMP_WORDS=(\"\${args[@]}\" \"\${COMP_WORDS[@]:1}\")
            local expanded_COMP_LINE=\${COMP_WORDS[*]}
            let COMP_POINT+=\${#expanded_COMP_LINE}-\${#COMP_LINE}
            COMP_LINE=\$expanded_COMP_LINE
            $completion_function \"\$@\"
        }
        "

        # To create the new completion we use the old one with two
        # replacements:
        # 1) Replace the function with the wrapper.
        local new_completion=${completion/-F * /-F $wrapper_name }
        # 2) Replace the command being completed with the alias.
        new_completion="${new_completion% *} $alias_name"

        eval "$new_completion"
    }

    # For each defined alias, extract the necessary elements and use them
    # to call wrap_alias.
    eval "$(
        alias -p | grep -v '[";|&]' |
        sed -e 's/alias -- /alias /; s/^alias \([^=][^=]*\)='\''\(.*\)'\''/\1 \2/' |
        while read shorthand definition; do
            # lightly parse the alias definition to pick out the command
            read -a defn_words <<<"$definition"
            set -- "${defn_words[@]}"
            while true; do
                command=$1; shift
                case $command in (*=*) ;; (*) break;; esac
            done
            printf '%q ' ${alias_completion_namespace}wrap_alias "$shorthand" "$command" "$definition"; echo
        done
    )"
}
